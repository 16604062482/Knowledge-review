```js
<ul>
  <li>1</li>
  <li>2</li>
</ul>
// vnode:
{
  tag: 'ul',
  children: [
   { tag: 'li', children: [ { vnode: { text: '2' }}]  },
   { tag: 'li', children: [ { vnode: { text: '1' }}]  },
  ]
}
```

- diff 过程：

  - 先判断 新老节点 是不是相同的 tag, 用到 isSameNode 方法

  - 不是相同节点，直接销毁旧 vnode，渲染新 vnode

  - 是相同节点，要尽可能的做节点的复用

    - 新旧 vnode 是文本，若 text 值不同，直接替换 text 值

    - 新旧 vnode 不是文本，包含 children，对子节点 children 进行对比

      - 新增 children，直接 addVnodes 添加新子节点。

      - 删除 children，直接 removeVnodes 删除旧子节点。

      - children 的 diff：【oldStartIndex、oldEndIndex、newStartIndex、newEndIndex】

        > 根据 4 个指针，在一个 while 循环中不停对比新旧节点的两端，把两端的指针向不断内部收缩，直到没有节点可以对比。

        - 主要对比的函数：sameVnode【两个节点的 key 相同，tag 相同....】

        - 4 个指针，新老组合。一共四种方案。判断节点能否复用。

        - 以上 4 个指针都不能复用，做所有旧子节点的 key -> index 映射，用新 vnode 的 key 去找出在旧节点中可以复用的位置。

        - 然后不停的把指针向内部收缩，直到新旧节点有一端的指针相遇（说明这个端的节点都被 patch 过了）。

- index 不能作为 key 的原因：

  - array 的 reverse 操作，如果 index 为 key。新老 vnode 的 key 没变，props 的值变了。导致节点不能复用

- 当数据发生改变时，订阅者 watcher 就会调用 patch 给真实的 DOM 打补丁

  - 通过 isSameVnode 进行判断，相同则调用 patchVnode 方法

  - 【patchVnode】 做了以下操作：

    - 找到对应的真实 dom，称为 el

    - 如果都有都有文本节点且不相等，将 el 文本节点设置为 Vnode 的文本节点

    - 如果 oldVnode 有子节点而 VNode 没有，则删除 el 子节点

    - 如果 oldVnode 没有子节点而 VNode 有，则将 VNode 的子节点真实化后添加到 el

    - 如果两者都有子节点，则执行 updateChildren 函数比较子节点

      - 【updateChildren】做了以下操作：

      - 设置新旧 VNode 的头尾指针

      - 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 patchVnode 进行 patch 重复流程、调用 createElem 创建一个新节点，从哈希表寻找 key 一致的 VNode 节点再分情况操作
