- 依赖收集：

  - 每个组件被挂载的时候，vue 会创建一个 watcher。watcher 回将自己挂到 Deo.target 方法上。表示刚刚创建的 watcher 正在进行依赖收集
    > 组件的 data（）方法的返回值，通过 defineReactive 方法，给每个属性定义 getter 和 setter 方法和对应的 Dep 实例。
  - vue 调用 watcher 进行求值运算。多有的依赖都会被取值
  - 取值时 getter 被调用，如果在 Dep 实例上有 watcher 正在进行依赖收集，getter 回调用 dep 实例对象的 depend 方法，建立当前属性值与 Dep 的关联。完成整个依赖收集。

  > 取值的时候依赖收集，设值的时候更新视图
  > 就是观察者模式。被观察者就是数组（dep）。观察者就是 watcher（渲染 watcher、计算属性、用户 watcher）
  > 一个 watcher 中可能对应多个数组，watcher 中还需要保存 dep（重新渲染的时候可以让属性重新记录 watcher）
  > 多对多的关系。一个 dep 对应多个 watcher，一个 watcher 对应多个 dep。默认渲染的时候会进行依赖收集（会出发 get 方法）。数据更新了就找到属性对应的 watcher 去更新

- 响应式：可以监控一个数据的修改和获取操作，针对对象格式会给每个对象的属性进行劫持 Object.defineProperty

  > 源码上 首先调用 initData 进行初始化，->然后调用 observe 方法吧数据变成响应式，之后调用 defineReactive 方法，对所有属性进行重写。对于对象类型，进行递归，对每个 key 进行响应式处理。
  > 因此，在 vue 中，避免层级过深。如果 data 中的对象不需要响应式，可以用 Object.freeze()来冻结对象。

- 检测数组的变化

  > vue2 中检测数组的变化，没有采用 defineProperty，因为修改索引的情况不多。如果直接用 defineProperty 会浪费性能。采用重写数组变异方法的方式（函数劫持）
  > initData-> observe ->对我们传入的数组进行原型链修改，后续调用的方法都是重写后的方法 ->对数组中的每个对象也再次代理
  > 修改数组索引、修改数组长度，无法监控。不会触发视图更新

  - 会改变数组的方法：pop()、push() shift()、unshift()、 splice()、reverse()、sort()
  - 不会改变数组的方法：slice()、join()、split()、concat()

- 模版编译：用户传递 template 属性，需要将 template 编译成 render 函数

  - template -> ast 语法树
  - 对语法树进行标记
  - 将 ast 语法树生层 render 函数
    > 最终每次渲染可以调用 render 函数返回对应的虚拟节点

- v-if 和 v-for 的优先级哪个更高

  > v-for 的优先级更高，在编译的时候，会将 v-for 渲染成\_l 函数，v-if 变成三元表达式
  > 源码中代码生成的时候，会先 生成 for 语法，再处理 if
  > v-if 和 v-show：
  > v-if 在编译的时候变成三元表达式。v-show 变成指令。一个是在编译的时候执行的，一个是在运行的时候执行的。v-show 会保存默认的 display 属性

- keep-alive：
  - 1.创建自定义组件，命名为 keep-alive
  - 2.在生命周期 created 中，创建一个缓存区{}
  - 3.render 方法中，取当前组件的插槽中，第一个虚拟节点
  - 4.生成唯一 key，key 缓存过，获取缓存实例，LRU 更新 key。key 没缓存过，缓存当前的 vnode 和 key
  - 5.给虚拟节点增加标识 vnode.data.vnode = true,最终返回 vnode
  - 6.mounted 中，渲染完成后，缓存虚拟节点 cacheVnode 缓存组件实例，下次访问 直接从缓存中取出，放到 vnode 中。vnode 上有 data.keepalive 为 true，说明是缓存过的
  - 7.缓存过的组件实例，返回给 vnode，重新进行组件的初始化，执行 init 方法
  - 8.组件 init 方法中，判断是不是 keepalive 的组件。如果不是，执行虚拟节点的重新渲染，走组件的初始化。如果是调用 prepatch 方法，拿到新老节点，走组件的更新方法，直接将缓存 data 插入
    > 总结：keep-alive 的原理是默认缓存加载过的组件对应的实例，内部采用 LRU 算法，下次组件切换加载的时候找到对应缓存的节点，来进行初始化。用上次缓存过的 $el 来触发。不用再将虚拟节点转化成真实节点。
