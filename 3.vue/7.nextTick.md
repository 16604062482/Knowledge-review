- 浏览器（多进程）包含了:

  > GUI 渲染线程
  > JS 引擎线程
  > 事件触发线程（和 EventLoop 密切相关）
  > 定时触发器线程
  > 异步 HTTP 请求线程
  
  > 和 Vue 的 nextTick 息息相关的是 JS 引擎线程和事件触发线程。

- JS 引擎线程和事件触发线程:

  - 浏览器页面初次渲染完毕后，JS 引擎线程结合事件触发线程的工作流程如下：

    > 同步任务在 JS 引擎线程（主线程）上执行，形成执行栈（Execution Context Stack）。
    > 主线程之外，事件触发线程管理着一个任务队列（Task Queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。
    > 执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其加到主线程的执行栈并执行相应的异步任务。

- 事件循环机制（Event Loop）

  - 主线程在运行时会产生执行栈，栈中的代码调用某些异步 API 时会在任务队列中添加事件，栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制，

- 任务类型：JS 中有两种任务类型：微任务（microtask）和宏任务（macrotask）

  > 在 ES6 中，microtask 称为 jobs，macrotask 称为 task。
  > 宏任务： script （主代码块）、setTimeout 、setInterval 、setImmediate 、I/O 、UI rendering
  > 微任务：process.nextTick（Nodejs） 、promise 、Object.observe 、MutationObserver

  - 宏任务并非全是异步任务，主代码块就是属于宏任务的一种（Promises/A+规范）。
  - 区别如下：

    > 宏任务是每次执行栈执行的代码（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
    > 浏览器为了能够使得 JS 引擎线程与 GUI 渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务执行开始之前，对页面进行重新渲染（宏任务 > 渲染 > 宏任务 > ...）
    > 微任务是在当前宏任务执行结束之后立即执行的任务（在当前 宏任务执行之后，UI 渲染之前执行的任务）。微任务的响应速度相比 setTimeout（下一个宏任务）会更快，因为无需等待 UI 渲染。
    > 当前宏任务执行后，会将在它执行期间产生的所有微任务都执行一遍。

    - 总结：

      > 宏任务中的事件是由事件触发线程来维护的
      > 微任务中的所有任务是由 JS 引擎线程维护的（这只是自我猜测，因为宏任务执行完毕后会立即执行微任务，为了提升性能，这种无缝连接的操作放在事件触发线程来维护明显是不合理的）。

    - 根据事件循环机制，重新梳理一下流程：

      > 执行一个宏任务（首次执行的主代码块或者任务队列中的回调函数）
      > 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
      > 宏任务执行完毕后，立即执行当前微任务队列中的所有任务（依次执行）
      > JS 引擎线程挂起，GUI 线程执行渲染
      > GUI 线程渲染完毕后挂起，JS 引擎线程执行任务队列中的下一个宏任务
