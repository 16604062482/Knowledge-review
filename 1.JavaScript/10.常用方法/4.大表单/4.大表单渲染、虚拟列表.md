- 对于一次性插入大量数据的情况，一般有两种做法：

  > 时间分片
  > 虚拟列表

- 对于大量数据渲染的时候，JS 运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段

- 时间分片：

  - setTimeout + 递归：跟屏幕刷新频率不一致 可能出现白屏

    ```js
    //需要插入的容器
    let ul = document.getElementById("container");
    // 插入十万条数据
    let total = 100000;
    // 一次插入 20 条
    let once = 20;
    //总页数
    let page = total / once;
    //每条记录的索引
    let index = 0;
    //循环加载数据
    function loop(curTotal, curIndex) {
      if (curTotal <= 0) {
        return false;
      }
      //每页多少条
      let pageCount = Math.min(curTotal, once);
      setTimeout(() => {
        for (let i = 0; i < pageCount; i++) {
          let li = document.createElement("li");
          li.innerText = curIndex + i + " : ";
          ul.appendChild(li);
        }
        loop(curTotal - pageCount, curIndex + pageCount);
      }, 0);
    }
    loop(total, index);
    ```

  - 使用 requestAnimationFrame：由系统来决定回调函数的执行时机。

    ```js
    let ul = document.getElementById("container");
    let total = 100000;
    let once = 20;
    let page = total / once;
    let index = 0;
    //循环加载数据
    function loop(curTotal, curIndex) {
      if (curTotal <= 0) {
        return false;
      }
      //每页多少条
      let pageCount = Math.min(curTotal, once);
      window.requestAnimationFrame(function () {
        for (let i = 0; i < pageCount; i++) {
          let li = document.createElement("li");
          li.innerText = curIndex + i + " : ";
          ul.appendChild(li);
        }
        loop(curTotal - pageCount, curIndex + pageCount);
      });
    }
    loop(total, index);
    ```

  - DocumentFragment：文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的 Document 使用。区别是 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的（重新渲染) ，且不会导致性能等问题。

    ```js
    let ul = document.getElementById("container");
    let total = 100000;
    let page = total / 20;
    let index = 0;
    function loop(curTotal, curIndex) {
      if (curTotal <= 0) {
        return false;
      }
      //每页多少条
      let pageCount = Math.min(curTotal, 20);
      window.requestAnimationFrame(function () {
        let fragment = document.createDocumentFragment();
        for (let i = 0; i < pageCount; i++) {
          let li = document.createElement("li");
          li.innerText = curIndex + i + " : ";
          fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        loop(curTotal - pageCount, curIndex + pageCount);
      });
    }
    loop(total, index);
    ```

- 虚拟列表：按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术。
  > 假设有 1 万条记录需要同时渲染，我们屏幕的可见区域的高度为 500px,而列表项的高度为 50px，则此时我们在屏幕中最多只能看到 10 个列表项，那么在首次渲染的时候，我们只需加载 10 条即可。
  > 当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。假设滚动发生，滚动条距顶部的位置为150px,则我们可得知在可见区域内的列表项为第4项至`第13项。