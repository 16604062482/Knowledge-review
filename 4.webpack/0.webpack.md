- webpack 配置：

  - 单个配置对象
  - 配置对象数组
  - 函数

- 配置数组

```js
    module.exports[
        {
            entry:'xxx.js',
            ...
        },
        {
            entry:'xxx.js',
            ...
        },
    ]
```

- webpack 启动后会创建多个 compilation 实例，并行构建工作。实例间不通信，其他 compilation 之间的构建结果无法复用

- 配置多个入口：webpack-merge

```js
    const {merge} = require('webpack-merge')
    const baseConfig = {}
    moudle.exports = [
        merge{baseConfig,{...}},
        merge{baseConfig,{...}},
    ]
```

- 将公共部分抽离为 baseConfig 对象，之后用 webpack-merge 创建不同目标数组项

- 配置对象：

```js
    moudles.exports = function(env,argv){
        return{
            entry:'xxx.js',
            ...
        }
    }
```

- webpack 会传入两个参数：

  - env：通过--env 命令行参数传入
  - argv：命令行的 Flags 参数

- webpack 持久化缓存 -- 主要提升开发环境的构建速度

  > 将首次构建的过程与构建结果 持久化保存到本地文件系统，下次执行时跳过解析、编译等操作，复用上次的 chunk 对象数据

  ```js
  module.exports = {
    cache: {
      type: "filesystem", // cache.type：缓存类型 memory/filesystem
    },
  };
  ```

- webapck 的构建阶段：
  - 从 entry 模块开始，读取文件内容
  - 调用 loader 转译
  - 调用 acorn 生成 ast
  - 分析 ast，生成模块依赖列表
  - 生成完整的 mudoleGraph 对象
- webpack 的生成阶段：

  - 遍历模块依赖列表，对每个模块，进行代码转移，import 转为 require。分析运行时依赖
  - 合并模块代码与运行时代码，生成 chunk
  - 执行产物优化，tree-shanking
  - 将最终产物写道产物文件

- webpack5 的持久化缓存，在下次编译时对比每个文件的内容 hash，没变的文件跳过编译，变了的文件重新编译


- 【方案 1】chache-loader：webpack5 之前，借助插件实现类似的效果。chache-loader 将 loader 处理结果放到硬盘中。下次文件没变直接返回结果。缓存范围和精度不如 webpack5 内置的缓存
- 【方案 2】hard-source-webpack-plugin：效果几乎与 webpack5 自带的 cache 对奇。性能稍差。

- 专用的缓存组件：

  - bable-loader：针对 loader 工具的专用缓存
  - eslint-loader：针对 eslint 的专用缓存

- webpack 优化：

  - thread-loader：开启多进程打包，提高构建的速度。

    > 使用方法是：将 thread-loader 放在比较费时间的 loader 之前，比如 babel-loader

  - cache-loader：缓存资源，提高二次构建的速度。

  - 开启热更新：如果你修改了项目中某一个文件，导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间

  - exclude & include
    > exclude：不需要处理的文件
    > include：需要处理的文件

  ```js
    // webpack.base.js
      {
        test: /\.js$/,
        //使用include来指定编译文件夹
        include: path.resolve(__dirname, '../src'),
        //使用exclude排除指定文件夹
        exclude: /node_modules/,
        use: [
          'babel-loader'
        ]
      },
  ```

  - tree-shaking：只打包用到的代码，没用到的代码不打包，而 webpack5 默认开启 tree-shaking，当打包的 mode 为 production 时，自动开启 tree-shaking 进行优化

  - webpack-bundle-analyzer:审查打包后的体积分布，进而进行相应的体积优化

  - 模块懒加载：如果不进行模块懒加载的话，最后整个项目代码都会被打包到一个 js 文件里，单个 js 文件体积非常大，那么当用户网页请求的时候，首屏加载时间会比较长，使用模块懒加载之后，大 js 文件会分成多个小 js 文件，网页加载时会按需加载，大大提升首屏加载速度

  - Gzip：开启 Gzip 后，大大提高用户的页面加载速度，因为 gzip 的体积比原文件小很多

  ```js
  // webpack.prod.js
  const CompressionPlugin = require("compression-webpack-plugin");
  plugins: [
    // 之前的代码...
    // gzip
    new CompressionPlugin({
      algorithm: "gzip",
      threshold: 10240, //以字节为单位压缩超过此大小的文件，使用默认值10240
      minRatio: 0.8, // 最小压缩比率，官方默认0.8
      //是否删除原有静态资源文件，即只保留压缩后的.gz文件，建议这个置为false，还保留源文件。
      deleteOriginalAssets: false,
    }),
  ];
  ```

  - 小图片转 base64：这样可以减少用户的http网络请求次数，提高用户的体验

  ```js
    // webpack.base.js
    {
      test: /\.(png|jpe?g|gif|svg|webp)$/,
      type: 'asset',
      parser: {
        // 转base64的条件
        dataUrlCondition: {
            maxSize: 25 * 1024, // 25kb
        }
      },
      generator: {
        // 打包到 image 文件下
        filename: 'images/[contenthash][ext][query]',
      },
    },
  ```
