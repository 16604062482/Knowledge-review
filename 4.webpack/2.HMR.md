- Hot Module Replacement，简称 HMR，无需完全刷新整个页面的同时，更新模块。HMR 的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。

- 刷新页面一般有两种结果：

  > 一种是不保留页面状态，就是简单粗暴，直接 window.location.reload()。
  > 另一种是基于 WDS (Webpack-dev-server)的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。
  > HMR 作为一个 Webpack 内置的功能，可以通过 HotModuleReplacementPlugin 或--hot 开启。

  ```js
  module.exports = {
    // webpack-dev-server配置
    devServer: {
      // 配置站点根目录，默认为输出位置
      static: path.resolve(__dirname, "dist"),
      // 设置端口号
      port: 8080,
      // 自动打开浏览器，访问index.html
      open: true,
      // 开启hmr
      hot: true,
    },
    plugins: [new webpack.HotModuleReplacementPlugin()],
  };
  ```

- 项目启动后，进行构建打包，控制台会输出构建过程，会生成了一个 Hash 值：a93fd735d02d98633356。

- 根据新生成文件名可以发现，上次输出的 Hash 值会作为本次编译新生成的文件标识。以此类推，本次输出的 Hash 值会被作为下次热更新的标识。

- webpack-dev-server.js：

  > 启动 webpack，生成 compiler 实例。compiler 上有很多方法，比如可以启动 webpack 所有编译工作，以及监听本地文件的变化。
  > 使用 express 框架启动本地 server，让浏览器可以请求本地的静态资源。
  > 本地 server 启动之后，再去启动 websocket 服务.通过 websocket，可以建立本地服务和浏览器的双向通信。这样就可以实现当本地文件发生变化，立马告知浏览器可以热更新代码啦！

- 通过插件 webpack-dev-middleware，实现对本地文件的监听

- webpack-dev-server 初始化 的过程中，启动的是本地服务端的 websocket。

- bundle.js 中，运行在浏览器中。其中 socket 方法建立了 websocket 和服务端的连接，并注册了 2 个监听事件。

  > hash 事件，更新最新一次打包后的 hash 值。
  > ok 事件，进行热更新检查。

- 核心逻辑：hotApply 热更新模块替换

  > 1.删除过期的模块，就是需要替换的模块.通过 hotUpdate 可以找到旧模块
  > 2.将新的模块添加到 modules 中 
  > 3.通过**webpack_require**执行相关模块的代码
