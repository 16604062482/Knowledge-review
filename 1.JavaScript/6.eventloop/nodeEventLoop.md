* Node 中的 Event Loop:
> 是基于 libuv 实现的，而 libuv 是 Node 的新跨平台抽象层.封装了不同操作系统一些底层特性，对外提供统一的 API

* Node.js 的运行机制如下:
- V8 引擎解析 JavaScript 脚本。
- 解析后的代码，调用 Node API。
- libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
- V8 引擎再将结果返回给用户。

> Node 的 Event loop 一共分为 6 个阶段：

- timers: 执行 timer（setTimeout、setInterval）的回调.
- I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调.
- idle, prepare: 仅在内部使用。
- poll: 获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里.
- check: 执行 setImmediate 的 callback。
  > setImmediate():是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行 setImmediate 指定的回调函数
- close callbacks: 执行 socket 的 close 事件回调
> 执行顺序：
    外部输入数据 –> 轮询阶段(poll) –> 检查阶段(check) –> 关闭事件回调阶段(close callback)
    –> 定时器检测阶段(timer) –> I/O 事件回调阶段(I/O callbacks) –> 闲置阶段(idle, prepare) –> 轮询阶段（按照该顺序反复运行）…



* 进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位

      - 进程好比工厂，有单独的专属自己的工厂资源。
      - 线程好比工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n 的关系。
      也就是说一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
      - 工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可用这些共享内存。
      - 多个工厂之间独立存在。

  > 以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

  > 一个浏览器通常由以下常驻线程组成：

  - GUI 渲染线程（图形用户界面 - Graphical User Interface）:
    主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。
    当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
    该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。

  - JavaScript 引擎线程:
    该线程主要负责处理 JavaScript 脚本，执行代码。
    也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。
    该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。

  - 定时触发器线程:
    负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
    主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。

  - 事件触发线程:
    主要负责将准备好的事件交给 JS 引擎线程执行。
    比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。

  - 异步 http 请求线程:
    负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。
    主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。


* 浏览器和 Node 环境下，microtask 任务队列的执行时机不同
- Node 端，microtask 在事件循环的各个阶段之间执行
- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
