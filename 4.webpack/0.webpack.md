- webpack 配置：

  - 单个配置对象
  - 配置对象数组
  - 函数

- 配置数组

```js
    module.exports[
        {
            entry:'xxx.js',
            ...
        },
        {
            entry:'xxx.js',
            ...
        },
    ]
```

- webpack 启动后会创建多个 compilation 实例，并行构建工作。实例间不通信，其他 compilation 之间的构建结果无法复用

- 配置多个入口：webpack-merge

```js
    const {merge} = require('webpack-merge')
    const baseConfig = {}
    moudle.exports = [
        merge{baseConfig,{...}},
        merge{baseConfig,{...}},
    ]
```

- 将公共部分抽离为 baseConfig 对象，之后用 webpack-merge 创建不同目标数组项

- 配置对象：

```js
    moudles.exports = function(env,argv){
        return{
            entry:'xxx.js',
            ...
        }
    }
```

- webpack 会传入两个参数：

  - env：通过--env 命令行参数传入
  - argv：命令行的 Flags 参数

- webpack 持久化缓存 -- 主要提升开发环境的构建速度

  > 将首次构建的过程与构建结果 持久化保存道本地文件系统，下次执行时跳过解析、编译等操作，复用上次的 chunk 对象数据

  ```js
  module.exports = {
    cache: {
      type: "filesystem", // cache.type：缓存类型 memory/filesystem
    },
  };
  ```

- webapck 的构建阶段：
  - 从 entry 模块开始，读取文件内容
  - 调用 loader 转译
  - 调用 acorn 生成 ast
  - 分析 ast，生成模块依赖列表
  - 生成完整的 mudoleGraph 对象
- webpack 的生成阶段：

  - 遍历模块依赖列表，对每个模块，进行代码转移，import 转为 require。分析运行时依赖
  - 合并模块代码与运行时代码，生成 chunk
  - 执行产物优化，tree-shanking
  - 将最终产物写道产物文件

- webpack5 的持久化缓存，在下次编译时对比每个文件的内容 hash，没变的文件跳过编译，变了的文件重新编译

- 【方案 1】chache-loader：webpack5 之前，借助插件实现类似的效果。chache-loader 将 loader 处理结果放到硬盘中。下次文件没变直接返回结果。缓存范围和精度不如 webpack5 内置的缓存
- 【方案 2】hard-source-webpack-plugin：效果几乎与 webpack5 自带的 cache 对奇。性能稍差。

- 专用的缓存组件：
  - bable-loader：针对 loader 工具的专用缓存
  - eslint-loader：针对 eslint 的专用缓存
