- let:
  > es6 新增了 let 命令，用于声明变量。let 所声明的变量只在 let 所在的代码块内部有效。
  - 不存在变量：
    > var 命令回发生“变量提升”现象，即变量可以再声明之前使用，值为 undefined。let 不存在变量提升，let 声明的变量一定要在声明后使用，否则会报错。
  - 暂时性死区：
    > 在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。（区块中存在 let、const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域）
  - 不允许重复声明：let 不允许在相同作用域内，重复声明一个变量。
  - 块级作用域：es5 只有全局作用域和函数作用域，let 为 js 增加了块级作用域。
  - 函数：
    - 允许在块级作用域中申明函数。
    - 函数声明类似于 var，会提升到全局作用域或函数作用域的头部。
    - 函数声明会提升到所在的块级作用域的头部。
  - es6 的块级作用域必须有大括号。否则 js 引擎认为不存在块级作用域。
- const：

  > const 声明一个只读的常量，一旦声明，常量的值就不能改变。

  - const 只声明，不赋值会报错。
  - 不存在变量提升。
  - 暂时性死区。
  - 不允许重复声明。
  - 块级作用域。
  - 对于基础数据类型，值不变。引用数据类型，地址不变。
  - 对象冻结--Object.freeze

- 变量声明的六种方法：
  var、function
  let、const、import、class

- 解构赋值：对数组和对象 进行解构赋值
  - 数组的解构赋值：只要具有 iterator 接口的数据结构，都可以采用数组形式的解构赋值。
  - 对象的解构赋值：变量必须和属性同名才可以解构赋值。
  - 默认值：es6 内部使用===判断一个位置是否有值，只有当【数组/对象的属性值】严格等于 undefined，默认值才会生效
  ```c
      let [x = 1] = undefined
      x //1
  ```
  - 字符串、数值、布尔值的解构赋值：被转换成包装对象 String、Number、Boolean
  - 用途：
    - 交换变量的值：
    ```c
    [x,y] = [y,x]
    ```
    - 提取 json 数据：
    ```c
    let {id,data} = jsonData
    ```
- 字符串的扩展：

  - 字符串增加了 iterator 接口，可以被 for of 循环
  - 模版字符串：用反引号（`）标识
    > 可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
    - 模板字符串中嵌入变量，需要将变量名写在${}之中。
    - 模板字符串之中还能调用函数。
    ```c
        function fn() {
            return "Hello World";
        }
        `foo ${fn()} bar` // foo Hello World bar
    ```
  - include()：返回布尔值，是否找到了参数字符串
  - startsWith()：返回布尔值，参数字符串是否在原字符串的开头
  - endsWith()：返回布尔值，参数字符串是否在原字符串的尾部

  ```c
    let s = 'Hello world!';
    s.startsWith('Hello') // true
    s.endsWith('!') // true
    s.includes('o') // true
  ```

  - 以上三个方法都支持第二个参数，表示开始搜索的位置。

  ```c
    let s = 'Hello world!';
    s.startsWith('world', 6) // true
    s.endsWith('Hello', 5) // true
    s.includes('Hello', 6) // false
  ```

  - repeat()：返回一个新字符串，表示将原字符串重复 n 次。参数如果是小数，会被取整。参数是负数或者 Infinity，会报错。
  - padStart()、padEnd()：用于头部补全、尾部补全。一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。

  ```c
    'x'.padStart(5, 'ab') // 'ababx'
    'x'.padStart(4, 'ab') // 'abax'
  ```

  - 如果原字符串的长度，等于或大于最大长度，则返回原字符串。

  ```c
    'xxx'.padStart(2, 'ab') // 'xxx'
    'xxx'.padEnd(2, 'ab') // 'xxx'
  ```

  - 如果省略第二个参数，默认使用空格补全长度。
  - trimStart()、trimEnd()：消除字符串头部、尾部的空格。
  - matchAll()：返回一个正则表达式在当前字符串的所有匹配。
  - replaceAll：一次性替换所有匹配
    > replace()只能替换第一个匹配。

  ```c
    'aabbcc'.replace('b', '_') // 'aa_bcc'
  ```

  - at()：接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）

  ```c
    //如果参数位置超出了字符串范围，at()返回undefined。
    const str = 'hello';
    str.at(1) // "e"
    str.at(-1) // "o"
  ```

- 正则：

  - es5 构造函数：
    - 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。
    ```c
        var regex = new RegExp('xyz', 'i');
        // 等价于
        var regex = /xyz/i;
    ```
    - 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。
    ```c
    var regex = new RegExp(/xyz/i);
    // 等价于
    var regex = /xyz/i;
    ```
  - es6 构造函数：
    第一个参数是一个正则对象，可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。

  ```c
      new RegExp(/abc/ig, 'i').flags //原有正则对象的修饰符是ig，它会被第二个参数i覆盖。
  ```

  - RegExp.prototype.flags 属性：会返回正则表达式的修饰符

  ```c
      // ES5 的 source 属性,返回正则表达式的正文
      /abc/ig.source // "abc"

      // ES6 的 flags 属性,返回正则表达式的修饰符
      /abc/ig.flags // 'ig'
  ```

- Number
  - 允许 JavaScript 的数值使用下划线（\_）作为分隔
  - Number.isFinite(), Number.isNaN()：用来检查一个数值是否为有限的（finite），即不是 Infinity。用来检查一个值是否为 NaN。
    > 与传统的全局方法 isFinite()和 isNaN()的区别：传统方法先调用 Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，对于非数值一律返回 false。
  - Number.parseInt(), Number.parseFloat()：将全局方法 parseInt()和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。
    > 这样做的目的：是逐步减少全局性方法，使得语言逐步模块化。
  - Number.EPSILON：实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。
- Math

  - Math.trunc()：用于去除一个数的小数部分，返回整数部分。
    > 对于非数值，Math.trunc 内部使用 Number 方法将其先转为数值。对于空值和无法截取整数的值，返回 NaN。
  - Math.sign()：用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
    > 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回 0； 参数为-0，返回-0; 其他值，返回 NaN。

- BigInt：BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。

  > JavaScript 所有数字都保存成 64 位浮点数,导致：
  > 一是数值的精度只能到 53 个二进制位，大于这个范围的整数，JavaScript 是无法精确表示。
  > 二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 Infinity。

- 函数

  - ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
  - rest 参数（...变量名）：用于获取函数的多余参数，代替 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
  - name 属性：函数的 name 属性，返回该函数的函数名。
  - 箭头函数：

    > 箭头函数没有自己的 this 对象（内部的 this 就是定义时上层作用域中的 this）。
    > 不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否则会抛出一个错误。
    > 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
    > 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

  - 尾调用：就是指某个函数的最后一步是调用另一个函数。

    > 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。等到 B 运行结束，将结果返回到 A，B 的调用帧才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
    > 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

  - 尾调用优化:只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

  * 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

    ```c
        function f() {
            let m = 1;
            let n = 2;
            return g(m + n);
        }
        f();

        function f() { // 等同于
             g(3);
        }
        f();

        g(3); // 等同于
    ```

    - 尾递归：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

    ```c
        //计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。
        function factorial(n) {
            if (n === 1) return 1;
            return n * factorial(n - 1);
        }
        factorial(5) // 120

        // 改写成尾递归，只保留一个调用记录，复杂度 O(1) 。
        function factorial(n, total) {
            if (n === 1) return total;
            return factorial(n - 1, n * total);
        }
        factorial(5, 1) // 120
    ```

    ```c
        // 非尾递归的 Fibonacci 数列
        function Fibonacci (n) {
            if ( n <= 1 ) {return 1};
            return Fibonacci(n - 1) + Fibonacci(n - 2);
        }
        // 尾递归优化过的 Fibonacci 数列
        function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
            if( n <= 1 ) {return ac2};
            return Fibonacci2 (n - 1, ac2, ac1 + ac2);
        }
    ```

- 数组

  - 扩展运算符（...）：将一个数组转为用逗号分隔的参数序列
    > 复制数组（拷贝第一层）：
    ```c
      const a2 = [...a1];
    ```
    > 合并数组
    > 实现了 Iterator 接口的对象：任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。
  - Array.from()：用于将两类对象转为真正的数组：类似数组的对象、和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）
  - Array.of()：用于将一组值，转换为数组。

  ```c
    Array.of(3, 11, 8) // [3,11,8]
  ```

  - find()：找出第一个符合条件的数组成员。
    > 它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。

  ```c
    [1, 4, -5, 10].find((n) => n < 0) //-5
  ```

  - findIndex()：用法与 find()方法类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
  - findLast()，findLastIndex()：从数组的最后一个成员开始，依次向前检查，其他都保持不变。
  - fill()：使用给定值，填充一个数组。还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

  ```c
    new Array(3).fill(7) // [7, 7, 7]
  ```

  - entries()，keys() 和 values()：用于遍历数组。

    > 它们都返回一个遍历器对象,可以用 for...of 循环进行遍历，唯一的区别是
    > keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

  - Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。
    > Map 结构的 has 方法，是用来查找键名的，比如 Map.prototype.has(key)
    > Set 结构的 has 方法，是用来查找值的，比如 Set.prototype.has(value)
  - flat() ：将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。只拉平一层。
  - flatMap() ：方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。该方法返回一个新数组，不改变原数组。
  - toReversed()，toSorted()，toSpliced()，with()：允许对数组进行操作时，不改变原数组，而返回一个原数组的拷贝。
    > toReversed()对应 reverse()，用来颠倒数组成员的位置。
    > toSorted()对应 sort()，用来对数组成员排序。
    > toSpliced()对应 splice()，用来在指定位置，删除指定数量的成员，并插入新成员。
    > with(index, value)对应 splice(index, 1, value)，用来将指定位置的成员替换为新的值。
  - group()：参数是一个分组函数，原数组的每个成员都会依次执行这个函数，确定自己是哪一个组。

  ```c
    const array = [1, 2, 3, 4, 5];
    array.group((num, index, array) => {
      return num % 2 === 0 ? 'even': 'odd';
    }); // { odd: [1, 3, 5], even: [2, 4] }
  ```

  - groupToMap()：用法与 group()完全一致，唯一的区别是返回值是一个 Map 结构，而不是对象。
  - Array.prototype.sort() 的排序稳定性：

  ```c
    const arr = [
      'peach','straw','apple','spork'
    ];
    //对arr按照首字母进行排序。结果中，straw在spork的前面，跟原始顺序一致，所以是稳定排序。
    const stableSorting = (s1, s2) => {
      if (s1[0] < s2[0]) return -1;
      return 1;
    };
    arr.sort(stableSorting) // ["apple", "peach", "straw", "spork"]
  ```

  ```c
    //排序结果：spork在straw前面，跟原始顺序相反，所以是不稳定
    const unstableSorting = (s1, s2) => {
      if (s1[0] <= s2[0]) return -1;
      return 1;
    };

    arr.sort(unstableSorting)
    // ["apple", "peach", "spork", "straw"]
  ```

  > 常见的排序算法之中，插入排序、合并排序、冒泡排序 等都是稳定的.
  > 堆排序、快速排序 等是不稳定的。
  > 不稳定排序的主要缺点是：多重排序时可能会产生问题。
  > 早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。
  > ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。
  > 现在 JavaScript 各个主要实现的默认排序算法都是稳定的。

- 对象
